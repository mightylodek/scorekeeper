import React from "react";
import PostMatch from "./PostMatch";
/**
 * 
 * Event Specific variables.  
 * In the future this should be setup as a context via 
 *   an event onboarding funnel
 * 
const eventName= 'Kings Cup 2023';

*/

export const createTeams = (teamNameArray) => {
  console.log("teamNameArray in kings", teamNameArray);
  const multipleOf4 = (arr) => (arr.length % 4 === 0 ? true : false);
  const hasDuplicates = (arr) => new Set(arr).size !== arr.length;
  const isOdd = (arr) => (arr.length % 2 == 0 ? false : true);
  const numAttempts = 25;
  const shuffleArray = (arr) =>
    arr.sort(function (a, b) {
      return 0.5 - Math.random();
    });

  const orderNames = (name1, name2) => {
    return [name1, name2].sort((a, b) => a.localeCompare(b));
  };

  const assignNames = (names) => {
    if (hasDuplicates(names)) {
      throw new Error("DUPLICATE_NAMES");
    }
    //    if (isOdd(names)) {
    //      throw new Error("ODD_NUMBER");
    //    }
    if (!multipleOf4(names)) {
      const diff = 4 - (names.length % 4);
      for (var i = 1; i <= diff; i++) {
        names.push(`BlankPlayer${i}`);
      }
    }
    const list = shuffleArray(names);
    return list
      .map((name, index, array) => {
        const teamMate = array[index + 1] ? array[index + 1] : array[0];
        if (index % 2 == 0) return orderNames(name, teamMate);
      })
      .filter((val) => val != undefined);
  };

  const assignNewNames = (arr, arrPrevPairs, attempts) => {
    if (attempts <= 0) {
      throw new Error("UNABLE_TO_MAKE_ALL_PAIRS_UNIQUE");
      return [];
    }
    const tempNames = assignNames(arr);
    const isAlreadyUsed = tempNames.map((team) => {
      const duplicatesFound = arrPrevPairs.some((elem) => {
        return elem.toString() === team.toString() ? true : false;
      });
      return duplicatesFound;
    });
    return isAlreadyUsed.some((elem) => elem === true)
      ? assignNewNames(arr, arrPrevPairs, attempts - 1)
      : tempNames;
  };

  const makePairedArray = (arr) => {
    return arr
      .map((team1, index, array) => {
        const team2 = array[index + 1] ? array[index + 1] : array[0];
        if (index % 2 == 0) return [team1, team2];
      })
      .filter((val) => val != undefined);
  };

  /**
   * Teams should have the structure of {teamName: "String", playersIds: [String]}
   * Since teams at Kings cup are autogenerated, we are adding a team name of "" for each team
   */

  const round1Teams = makePairedArray(assignNames(teamNameArray));
  const round2Teams = makePairedArray(
    assignNewNames(teamNameArray, round1Teams, numAttempts)
  );
  const round3Teams = makePairedArray(
    assignNewNames(teamNameArray, round1Teams.concat(round2Teams), numAttempts)
  );

  const round4Teams = makePairedArray(
    assignNewNames(
      teamNameArray,
      round1Teams.concat(round2Teams).concat(round3Teams),
      numAttempts
    )
  );

  console.log("Round1teams...", round1Teams);

  return [round1Teams, round2Teams, round3Teams, round4Teams];
};

export const populateMatches = (
  matchList,
  players,
  {
    maxScore = 11,
    winByTwo = false,
    eventName = "My Awesome Event",
    bracketName = "Exibition",
    bracketRound = "Round 1",
  }
) => {
  matchList.map((m, idx) => {
    const t1p1Name = players.find((player) => player.id === m[0][0]).name;
    const t1p2Name = players.find((player) => player.id === m[0][1]).name;
    const t2p1Name = players.find((player) => player.id === m[1][0]).name;
    const t2p2Name = players.find((player) => player.id === m[1][1]).name;

    const t1PlayerNames = t1p1Name + " & " + t1p2Name;
    const t2PlayerNames = t2p1Name + " & " + t2p2Name;
    const partialMD = {
      eventName: `${eventName}`,
      bracketName: `${bracketName}`,
      bracketRound: `${bracketRound}`,
      matchNumber: idx + 1,
      team1Name: t1PlayerNames,
      team1PlayerIds: m[0],
      team1PlayerNames: t1PlayerNames,
      team2Name: t2PlayerNames,
      team2PlayerIds: m[1],
      team2PlayerNames: t2PlayerNames,
      maxScore: maxScore,
      winByTwo: winByTwo,
      status: "Generated",
    };
    PostMatch(partialMD);
  });
};

/**
 * input: Array of teams where each item has an array of players on the team
 * [[ID1, ID2], [ID3, ID4]], [players]
 
const createMatches = (data, {
  maxScore = 11,
  winByTwo = false,
  eventName = "My Awesome Event",
  bracketName = "Exibition",
  bracketRound = "Round 1"}
) => {

    const team1Name = () => {
        if (team1name != ""){
            return team1name
         }
         else{
            let nameConcat = "";
            foreach(id in team1Ids){
                nameConcat += `${data.players[id].name} `;
            }
         }
    };
    const team2Name = () => {
        if (team2name != ""){
            return team2name
         }
         else{
            let nameConcat = "";
            foreach(id in team2Ids){
                nameConcat += `${data.players[id].name} `;
            }
         }
    };

  prelim1Matches.map(([team1Name, team2Name], idx) => {
    const partialMD = {
      eventName: `${eventName}`,
      bracketName: `${bracketName}`,
      bracketRound: `${bracketRound}`,
      matchNumber: idx + 1,
      team1Name: `${team1Name}`,
      team2Name: `${team2Name}`,
      maxScore: { maxScore },
      winByTwo: { winByTwo },
      status: "Generated",
    };
    PostMatch(partialMD);
  });
};

*/
