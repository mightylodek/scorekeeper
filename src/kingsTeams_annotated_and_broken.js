import React from "react";
/**
 * 
 * Event Specific variables.  
 * In the future this should be setup as a context via 
 *   an event onboarding funnel
 * 
const eventName= 'Kings Cup 2023';

*/

export const createTeams = (players) => {
  console.log("players array in kings", players);
  const multipleOf4 = (arr) => (arr.length % 4 === 0 ? true : false);
  const hasDuplicates = (arr) => new Set(arr).size !== arr.length;
  //const isOdd = (arr) => (arr.length % 2 == 0 ? false : true);
  const numAttempts = 25;

  /**
   * shuffleArray(arr)
   * @param {[]} arr: Any array.
   *    In the context of Kings Cup, it is to take an array of
   *    keys for the players object of objects
   * @returns the same array in random order
   *    In the context of Kings Cup, this will return an array
   *    of Ids to represent the players from the "players" object.
   *
   * *********Below is for reference only!!*********
   *    Which is itself an object with Ids as the keys
   *    data.players.id =
   *        {
   *            id: String,
   *            name: String,
   *            wins: Number,
   *            Losses: Number,
   *            pdiff: Number,
   *            Seed: number
   *        }
   */
  const shuffleArray = (arr) =>
    arr.sort(function (a, b) {
      return 0.5 - Math.random();
    });

  /**
   *
   * @param {String} name1
   * @param {String} name2
   * @returns an array where the first value is "before" the second
   *  based on the sort callback.  In the context of kings cup, this
   *  is alphabetical order of the two names that are passed
   */
  const orderPair = (name1, name2) => {
    return [name1, name2].sort((a, b) => a.localeCompare(b));
  };

  /**
   *
   * @param {{}} players
   *  players is an object of objects where each ID is the key to
   *  bring up an object with the below structure
   *
   * *    data.players.id =
   *        {
   *            id: String,
   *            name: String,
   *            wins: Number,
   *            Losses: Number,
   *            pdiff: Number,
   *            Seed: number
   *        }
   *
   * @returns [] list
   *  list is an array of ID pairs
   *      [[id1, id2], [id3, id4]...]
   *  The pairs are meant to be teammates and
   *  should be keys back to the "players" object
   *  that was passed into the asignPairs function
   *
   */
  const assignPairs = (players) => {
    if (hasDuplicates(players)) {
      throw new Error("DUPLICATE_PLAYERS");
    }
    if (!multipleOf4(players)) {
      const diff = 4 - (players.length % 4);
      for (var i = 1; i <= diff; i++) {
        players[`xx${i}`] = {
          id: `xx${i}`,
          name: "Blank",
          wins: 0,
          losses: 0,
          pdiff: 0,
          seed: 0,
        };
      }
    }

    const list = shuffleArray(players);
    return list
      .map((player, index, array) => {
        const teamMate = array[index + 1] ? array[index + 1] : array[0];
        if (index % 2 == 0) return orderPair(player, teamMate);
      })
      .filter((val) => val != undefined);
  };

  const assignNewPairs = (arr, arrPrevPairs, attempts) => {
    if (attempts <= 0) {
      throw new Error("UNABLE_TO_MAKE_ALL_PAIRS_UNIQUE");
      return [];
    }
    const tempNames = assignPairs(arr);
    const isAlreadyUsed = tempNames.map((team) => {
      const duplicatesFound = arrPrevPairs.some((elem) => {
        return elem.id === team.id ? true : false;
      });
      return duplicatesFound;
    });
    return isAlreadyUsed.some((elem) => elem === true)
      ? assignNewPairs(arr, arrPrevPairs, attempts - 1)
      : tempNames;
  };

  const makePairedTeamArray = (arr) => {
    return arr
      .map((team1, index, array) => {
        const team2 = array[index + 1] ? array[index + 1] : array[0];
        if (index % 2 == 0) return [team1, team2];
      })
      .filter((val) => val != undefined);
  };

  /**
   * Teams should have the structure of {teamName: "String", playersIds: [String]}
   * Since teams at Kings cup are autogenerated, we are adding a team name of "" for each team
   */

  const round1Teams = makePairedTeamArray(assignPairs(players));
  const round2Teams = makePairedTeamArray(
    assignNewPairs(players, round1Teams, numAttempts)
  );
  const round3Teams = makePairedArray(
    assignNewPairs(players, round1Teams.concat(round2Teams), numAttempts)
  );

  console.log("Round1teams...", round1Teams);

  return [round1Teams, round2Teams, round3Teams];
};

/**
 * input: Array of teams where each item has an array of players on the team
 * [[ID1, ID2], [ID3, ID4]], [players]
 
const createMatches = (data, {
  maxScore = 11,
  winByTwo = false,
  eventName = "My Awesome Event",
  bracketName = "Exibition",
  bracketRound = "Round 1"}
) => {

    const team1Name = () => {
        if (team1name != ""){
            return team1name
         }
         else{
            let nameConcat = "";
            foreach(id in team1Ids){
                nameConcat += `${data.players[id].name} `;
            }
         }
    };
    const team2Name = () => {
        if (team2name != ""){
            return team2name
         }
         else{
            let nameConcat = "";
            foreach(id in team2Ids){
                nameConcat += `${data.players[id].name} `;
            }
         }
    };

  prelim1Matches.map(([team1Name, team2Name], idx) => {
    const partialMD = {
      eventName: `${eventName}`,
      bracketName: `${bracketName}`,
      bracketRound: `${bracketRound}`,
      matchNumber: idx + 1,
      team1Name: `${team1Name}`,
      team2Name: `${team2Name}`,
      maxScore: { maxScore },
      winByTwo: { winByTwo },
      status: "Generated",
    };
    PostMatch(partialMD);
  });
};

*/
